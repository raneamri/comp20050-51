Index: src/BoardTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*import javafx.scene.Node;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport javafx.scene.shape.Polygon;\r\nimport org.junit.jupiter.api.Test;\r\n\r\npublic class BoardTest {\r\n    final int NUM_ROWS = 9;\r\n\r\n    @Test\r\n    void testCreateBoard(){\r\n        Board newBoard = new Board();\r\n\r\n        assertNotNull(newBoard.getCells());//Ensuring cells are created\r\n        assertEquals(NUM_ROWS, newBoard.getCells().length);//Ensuring the no of\r\nrows is correct\r\n\r\n        // Verify coordinates\r\n        for(int row = 0; row < NUM_ROWS/2; row++){\r\n            int expectedNumHexagons = row+5;\r\n            for(int col = 0; col < expectedNumHexagons; col++){\r\n                assertEquals(row, newBoard.getCells()[row][col].coords[0]);\r\n                assertEquals(col, newBoard.getCells()[row][col].coords[1]);\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    @Test\r\n    void testGetBoardGroup(){\r\n        Board newBoard = new Board();\r\n        newBoard.getBoardGroup();\r\n\r\n        boolean containsPolygon = false;\r\n\r\n        for(Node node : Main.getGroup().getChildren()){\r\n            if(node instanceof Polygon){\r\n                containsPolygon = true;\r\n                break;\r\n            }\r\n        }\r\n        //Ensure the hexagons are being added to main's group correctly\r\n        assertTrue(containsPolygon);\r\n    }\r\n\r\n    @Test\r\n    void testGetNumHexagonsInRow(){\r\n        Board newBoard = new Board();\r\n\r\n        int expectedHexagons = 5;\r\n        assertEquals(expectedHexagons, newBoard.getCells()[0].length);\r\n\r\n        expectedHexagons = 6;\r\n        assertEquals(expectedHexagons, newBoard.getCells()[1].length);\r\n\r\n        expectedHexagons = 9;\r\n        assertEquals(expectedHexagons, newBoard.getCells()[4].length);\r\n    }\r\n}*/\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/BoardTest.java b/src/BoardTest.java
--- a/src/BoardTest.java	(revision 1cbc092875b73fd4a5efd21f281d20a6f7cb5e32)
+++ b/src/BoardTest.java	(date 1709719415220)
@@ -1,4 +1,4 @@
-/*import javafx.scene.Node;
+import javafx.scene.Node;
 import static org.junit.jupiter.api.Assertions.*;
 
 import javafx.scene.shape.Polygon;
@@ -12,8 +12,7 @@
         Board newBoard = new Board();
 
         assertNotNull(newBoard.getCells());//Ensuring cells are created
-        assertEquals(NUM_ROWS, newBoard.getCells().length);//Ensuring the no of
-rows is correct
+        assertEquals(NUM_ROWS, newBoard.getCells().length);//Ensuring the no of rows is correct
 
         // Verify coordinates
         for(int row = 0; row < NUM_ROWS/2; row++){
@@ -56,4 +55,4 @@
         expectedHexagons = 9;
         assertEquals(expectedHexagons, newBoard.getCells()[4].length);
     }
-}*/
+}
Index: src/Ray.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import java.util.ArrayList;\r\nimport javafx.scene.paint.Color;\r\nimport javafx.scene.shape.Line;\r\nimport javafx.util.Pair;\r\n\r\npublic class Ray {\r\n  public enum ORDER { ROW_LR, ROW_RL, COL_LR, COL_RL }\r\n\r\n  private ArrayList<Pair<Double, Double>> coords = new ArrayList<>();\r\n  private ArrayList<Line> lines = new ArrayList<>();\r\n\r\n  public Ray(double startX, double startY, double endX, double endY) {\r\n    /**\r\n     * Prepare to draw rays\r\n     */\r\n    coords.add(new Pair<Double, Double>(startX, startY));\r\n    checkCollisions(startX, startY, endX, endY);\r\n\r\n    drawRays();\r\n  }\r\n\r\n  /**\r\n   * Calculates the slope of the line going through two points\r\n   *\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   * @return slope\r\n   */\r\n  public double getSlope(double x1, double y1, double x2, double y2) {\r\n    return (y2 - y1) / (x2 - x1);\r\n  }\r\n\r\n  /**\r\n   * Calculates the y-intercept of a line equation\r\n   * @param x1\r\n   * @param y1\r\n   * @param m\r\n   * @return y-intercept\r\n   */\r\n  public double getYIntercept(double x1, double y1, double m) {\r\n    return y1 - m * x1;\r\n  }\r\n\r\n  /**\r\n   * Checks if three points are collinear. Done by comparing slopes, with a\r\n   * level of error allowed\r\n   *\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   * @param x3\r\n   * @param y3\r\n   * @return true if collinear, false otherwise\r\n   */\r\n  public boolean isCollinear(double x1, double y1, double x2, double y2,\r\n                             double x3, double y3) {\r\n    double m1 = (y2 - y1) / (x2 - x1);\r\n    double m2 = (y3 - y2) / (x3 - x2);\r\n    double error = 1e-5;\r\n\r\n    return Math.abs(m1 - m2) < error;\r\n  }\r\n\r\n  /**\r\n   * Calculates the point(s) of contact between a line segment defined by two\r\n   * points and a circle defined by a center point and radius and decides which\r\n   * is significant for its purpose.\r\n   *\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   * @param centerX\r\n   * @param centerY\r\n   * @param radius\r\n   * @return the coordinates of the meaningful point of contact with the circle,\r\n   *     or null if there is none\r\n   */\r\n  public static double[] getPointOfContact(double x1, double y1, double x2,\r\n                                           double y2, double centerX,\r\n                                           double centerY, double radius) {\r\n\r\n    /**\r\n     * Vector components\r\n     */\r\n    double vecX = x2 - x1;\r\n    double vecY = y2 - y1;\r\n\r\n    /**\r\n     * Vector components from x1 y1 to center of circle\r\n     */\r\n    double vecCX = centerX - x1;\r\n    double vecCY = centerY - y1;\r\n\r\n    /**\r\n     * Length of segment squared\r\n     */\r\n    double a = vecX * vecX + vecY * vecY;\r\n\r\n    /**\r\n     * Dot product of vectors\r\n     */\r\n    double dotBy2 = vecX * vecCX + vecY * vecCY;\r\n    double c = vecCX * vecCX + vecCY * vecCY - radius * radius;\r\n\r\n    double pBy2 = dotBy2 / a;\r\n    double q = c / a;\r\n\r\n    double discriminant = pBy2 * pBy2 - q;\r\n\r\n    /**\r\n     * No intersection\r\n     */\r\n    if (discriminant < 0) {\r\n      return null;\r\n    }\r\n\r\n    /**\r\n     * Scaling factors along the line\r\n     */\r\n    double discSqrt = Math.sqrt(discriminant);\r\n    double abScalingFactor1 = -pBy2 + discSqrt;\r\n    double abScalingFactor2 = -pBy2 - discSqrt;\r\n\r\n    /**\r\n     * First intersection point (line intersects circle twice unless tangential)\r\n     */\r\n    double p1x = x1 - vecX * abScalingFactor1;\r\n    double p1y = y1 - vecY * abScalingFactor1;\r\n\r\n    /**\r\n     * Tangential therefore no need to check which point of contact we need\r\n     */\r\n    if (discriminant == 0) {\r\n      return new double[] {p1x, p1y};\r\n    }\r\n\r\n    /**\r\n     * Second intersection point\r\n     */\r\n    double p2x = x1 - vecX * abScalingFactor2;\r\n    double p2y = y1 - vecY * abScalingFactor2;\r\n\r\n    /**\r\n     * We only keep the intersection point closest to x1 y1\r\n     */\r\n    double d1 = Math.sqrt(Math.pow(p1x - x1, 2) + Math.pow(p1y - y1, 2));\r\n    double d2 = Math.sqrt(Math.pow(p2x - x1, 2) + Math.pow(p2y - y1, 2));\r\n\r\n    return d1 < d2 ? new double[] {p1x, p1y} : new double[] {p2x, p2y};\r\n  }\r\n\r\n  /**\r\n   * For a line interpreted as two points, this method checks for the first\r\n   * COI it'd intersect with\r\n   *\r\n   * @param x1\r\n   * @param y1\r\n   * @param x2\r\n   * @param y2\r\n   */\r\n  public void checkCollisions(double x1, double y1, double x2, double y2) {\r\n    for (Atom atom : Main.atoms) {\r\n      /**\r\n       * If they are collinear\r\n       */\r\n      if (isCollinear(x1, y1, x2, y2, atom.getCenterX(), atom.getCenterY())) {\r\n        /**\r\n         * This will be the last collision so we return the coordinates of the\r\n         * atom\r\n         */\r\n        System.out.println(\"Absorption at \" + atom.getCenterX() + \" \" +\r\n                           atom.getCenterY());\r\n        System.out.println(atom.coi.getRadius());\r\n        coords.add(\r\n            new Pair<Double, Double>(atom.getCenterX(), atom.getCenterY()));\r\n        return;\r\n      }\r\n\r\n      /**\r\n       * If they collide\r\n       */\r\n      double[] pointOfContact =\r\n          getPointOfContact(x1, y1, x2, y2, atom.getCenterX(),\r\n                            atom.getCenterY(), atom.coi.getRadius());\r\n      if (pointOfContact != null) {\r\n        /**\r\n         * Calculate point of collision of with COI\r\n         */\r\n        System.out.println(\"Collision at \" + pointOfContact[0] + \" \" +\r\n                           pointOfContact[1]);\r\n        coords.add(\r\n            new Pair<Double, Double>(pointOfContact[0], pointOfContact[1]));\r\n\r\n        /**\r\n         * Recursive call with next point\r\n         */\r\n        checkCollisions(atom.getCenterX(), atom.getCenterY(), pointOfContact[0],\r\n                        pointOfContact[1]);\r\n        return;\r\n      } else {\r\n        System.out.println(\"No collision\");\r\n        return;\r\n      }\r\n    }\r\n\r\n    /**\r\n     * No collisions left\r\n     */\r\n    return;\r\n  }\r\n\r\n  public void drawRays() {\r\n    if (coords.size() == 1) {\r\n      Line line =\r\n          new Line(coords.get(0).getKey(), coords.get(0).getValue(),\r\n                   coords.get(0).getKey() + 20, coords.get(0).getValue() + 20);\r\n      line.setFill(Color.YELLOW);\r\n      line.setStroke(Color.YELLOW);\r\n      line.setStrokeWidth(4);\r\n      lines.add(line);\r\n      Main.getGroup().getChildren().add(line);\r\n      return;\r\n    }\r\n\r\n    for (int i = 0; i < coords.size() - 1; i++) {\r\n      Line line =\r\n          new Line(coords.get(i).getKey(), coords.get(i).getValue(),\r\n                   coords.get(i + 1).getKey(), coords.get(i + 1).getValue());\r\n      /**\r\n       * Display parameters\r\n       */\r\n      line.setFill(Color.YELLOW);\r\n      line.setStroke(Color.YELLOW);\r\n      line.setStrokeWidth(4);\r\n      lines.add(line);\r\n      Main.getGroup().getChildren().add(line);\r\n    }\r\n  }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/Ray.java b/src/Ray.java
--- a/src/Ray.java	(revision 1cbc092875b73fd4a5efd21f281d20a6f7cb5e32)
+++ b/src/Ray.java	(date 1709760078956)
@@ -8,6 +8,7 @@
 
   private ArrayList<Pair<Double, Double>> coords = new ArrayList<>();
   private ArrayList<Line> lines = new ArrayList<>();
+  private Line createdLine;
 
   public Ray(double startX, double startY, double endX, double endY) {
     /**
@@ -223,6 +224,7 @@
       line.setStrokeWidth(4);
       lines.add(line);
       Main.getGroup().getChildren().add(line);
+        createdLine = line;
       return;
     }
 
@@ -240,4 +242,8 @@
       Main.getGroup().getChildren().add(line);
     }
   }
+
+  public Line getCreatedLine(){
+    return createdLine;
+  }
 }
Index: src/CellTest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*import javafx.scene.paint.Color;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport javafx.scene.shape.Polygon;\r\nimport org.junit.jupiter.api.Test;\r\n\r\npublic class CellTest {\r\n\r\n    @Test\r\n    void testCreateHexagon(){\r\n        Cell newCell = new Cell();\r\n        Polygon hexagon = newCell.createHexagon(40);\r\n\r\n        assertNotNull(hexagon);\r\n        assertEquals(Color.TRANSPARENT, hexagon.getFill());\r\n        assertEquals(Color.RED, hexagon.getStroke());\r\n    }\r\n\r\n    //Debugging fractures for mouse event in cell class\r\n\r\n}*/
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/CellTest.java b/src/CellTest.java
--- a/src/CellTest.java	(revision 1cbc092875b73fd4a5efd21f281d20a6f7cb5e32)
+++ b/src/CellTest.java	(date 1709719415173)
@@ -1,4 +1,4 @@
-/*import javafx.scene.paint.Color;
+import javafx.scene.paint.Color;
 import static org.junit.jupiter.api.Assertions.*;
 
 import javafx.scene.shape.Polygon;
@@ -18,4 +18,4 @@
 
     //Debugging fractures for mouse event in cell class
 
-}*/
\ No newline at end of file
+}
\ No newline at end of file
Index: src/AtomandCOITest.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>/*import javafx.scene.paint.Color;\r\nimport static org.junit.jupiter.api.Assertions.*;\r\n\r\nimport org.junit.jupiter.api.Test;\r\n\r\npublic class AtomandCOITest{\r\n\r\n    @Test\r\n    void testCreateAtom(){\r\n        Atom newAtom = new Atom(40, 40);\r\n        assertNotNull(newAtom);\r\n        assertEquals(Color.RED, newAtom.getFill());\r\n\r\n        newAtom.coi = new COI(40, 40);\r\n        assertNotNull(newAtom.coi);\r\n        assertEquals(Color.TRANSPARENT, newAtom.coi.getFill());\r\n        assertEquals(Color.WHITE, newAtom.coi.getStroke());\r\n\r\n        Atom newAtom2 = new Atom(35, 37);\r\n        assertNotNull(newAtom2);\r\n        assertEquals(Color.RED, newAtom2.getFill());\r\n\r\n\r\n    }\r\n\r\n    @Test\r\n    void testEquals(){\r\n        Atom atom1 = new Atom(10, 10);\r\n        Atom atom2 = new Atom(10, 10);\r\n\r\n        Atom atom3 = new Atom(30, 30);\r\n        Atom atom4 = new Atom(40, 40);\r\n\r\n        COI coi1 = null;\r\n        COI coi2 = new COI(40, 40);\r\n\r\n        assertTrue(atom1.equals(atom1));\r\n        assertTrue(atom1.equals(atom2));\r\n        assertFalse(atom3.equals(coi1));\r\n        assertFalse(atom4.equals(coi2));\r\n        assertEquals(atom1.equals(atom2), atom2.equals(atom1));\r\n    }\r\n\r\n}*/
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/AtomandCOITest.java b/src/AtomandCOITest.java
--- a/src/AtomandCOITest.java	(revision 1cbc092875b73fd4a5efd21f281d20a6f7cb5e32)
+++ b/src/AtomandCOITest.java	(date 1709719542204)
@@ -1,4 +1,4 @@
-/*import javafx.scene.paint.Color;
+import javafx.scene.paint.Color;
 import static org.junit.jupiter.api.Assertions.*;
 
 import org.junit.jupiter.api.Test;
@@ -41,4 +41,4 @@
         assertEquals(atom1.equals(atom2), atom2.equals(atom1));
     }
 
-}*/
\ No newline at end of file
+}
\ No newline at end of file
diff --git a/src/META-INF/MANIFEST.MF b/src/META-INF/MANIFEST.MF
new file mode 100644
